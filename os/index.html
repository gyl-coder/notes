


<!DOCTYPE html>
<html lang="en" class="with-v3-banner">
  <head>
    <title>Notes</title>
    <meta charset="utf-8">
    <meta name="description" content="Notes - Personal review warehouse">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="alternate" hreflang="x-default" href="https://vuejs.org/os/index.html">
    <link rel="alternate" hreflang="zh" href="https://cn.vuejs.org/os/index.html">
    <link rel="alternate" hreflang="ja" href="https://jp.vuejs.org/os/index.html">
    <link rel="alternate" hreflang="ru" href="https://ru.vuejs.org/os/index.html">
    <link rel="alternate" hreflang="ko" href="https://kr.vuejs.org/os/index.html">
    <link rel="alternate" hreflang="pt-BR" href="https://br.vuejs.org/os/index.html">
    <link rel="alternate" hreflang="fr" href="https://fr.vuejs.org/os/index.html">
    <link rel="alternate" hreflang="es" href="https://es.vuejs.org/os/index.html">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Notes">
    <meta property="og:description" content="Notes - Personal review warehouse">
    <meta property="og:image" content="https://vuejs.org//images/logo.png">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Notes">
    <meta name="twitter:description" content="Notes - Personal review warehouse">
    <meta name="twitter:image" content="https://vuejs.org/images/logo.png">

    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/images/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/images/icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/images/icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/icons/favicon-16x16.png">
    <meta name="msapplication-TileImage" content="/images/icons/ms-icon-144x144.png">
    <link rel="icon" href="/images/logo.png" type="image/png">

    <meta name="msapplication-TileColor" content="#4fc08d">
    <meta name="theme-color" content="#4fc08d">

    <meta name="msapplication-config" content="browserconfig.xml">
    <link rel="manifest" href="/manifest.json">

    <link href="https://fonts.googleapis.com" rel="preconnect" crossorigin>
    <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
    <link href="https://maxcdn.bootstrapcdn.com" rel="preconnect" crossorigin>

    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Dosis:500&text=Vue.js&display=swap" rel="stylesheet">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="/js/vue.js"></script>

    

    <script>
      Vue.config.productionTip = false
      window.PAGE_TYPE = ""
    </script>

    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-46852172-1', 'vuejs.org');
      ga('send', 'pageview');
    </script>

    <!-- vimeo analytics -->
    <script type="text/javascript" defer="defer" src="https://extend.vimeocdn.com/ga/72160148.js"></script>
  <meta name="generator" content="Hexo 5.4.0"></head>
  <body class="docs">
    <div id="mobile-bar" >
      <a class="menu-button"></a>
      <a class="logo" href="/"></a>
    </div>
    <div>
  <div id="v3-banner">
    <span class="hidden-sm">Welcome to yanliang's notes</span>
  </div>

  <header id="header">
    <a id="logo" href="/">
      <img src="/images/logo.png" alt="vue logo">
      <span>Notes - personal review warehouse</span>
    </a>
    <ul id="nav">
      <li>
  <form id="search-form">
    <input type="text" id="search-query-nav" class="search-query st-default-search-input" aria-label="Search">
  </form>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link">⭐️Java</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Documentation</h4></li>
    <li>
      <ul>
        <li><a href="/java/oop/" class="nav-link">OOP</a></li>
        <li><a href="/v2/api" class="nav-link">API</a></li>
        <li><a href="/v2/style-guide" class="nav-link">Style Guide</a></li>
        <li><a href="/v2/examples" class="nav-link">Examples</a></li>
        <li><a href="/v2/cookbook" class="nav-link">Cookbook</a></li>
      </ul>
    </li>
    <li><h4>Video Courses</h4></li>
    <li>
      <ul>
        <li>
          <a href="https://www.vuemastery.com/courses/" class="nav-link" target="_blank" rel="sponsored noopener">
            Vue Mastery
          </a>
        </li>
        <li>
          <a
            href="https://vueschool.io/?friend=vuejs&utm_source=Vuejs.org&utm_medium=Link&utm_content=Navbar%20Dropdown"
            class="nav-link"
            target="_blank" rel="sponsored noopener"
          >
            Vue School
          </a>
        </li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container learn">
  <a class="nav-link">网络</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <!-- <li><h4>Documentation</h4></li> -->
    <li>
      <ul>
        <li><a href="/network">Review List</a></li>
        <li><a href="/network/tcp/">🔥TCP</a></li>
        <li><a href="/network/http/">HTTP</a></li>
        <li><a href="/network/ip/">IP</a></li>
      </ul>
    </li>
    <li><h4>Video Courses</h4></li>
    <li>
      <ul>
        <li>
          <a href="https://www.vuemastery.com/courses/" class="nav-link" target="_blank" rel="sponsored noopener">
            Vue Mastery
          </a>
        </li>
        <li>
          <a
            href="https://vueschool.io/?friend=vuejs&utm_source=Vuejs.org&utm_medium=Link&utm_content=Navbar%20Dropdown"
            class="nav-link"
            target="_blank" rel="sponsored noopener"
          >
            Vue School
          </a>
        </li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="/os/">操作系统</a>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link">数据库</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <!-- <li><h4>Documentation</h4></li> -->
    <li>
      <ul>
        <li><a href="/mysql">Review List</a></li>
        <li><a href="/mysql/mysql-index">索引相关</a></li>
        <li><a href="/mysql/mysql-index-operation">索引操作相关</a></li>
        <li><a href="/mysql/mysql-lock">锁相关</a></li>
        <li><a href="/mysql/mysql-logs">日志相关</a></li>
        <li><a href="/mysql/mysql-mvcc">MVCC</a></li>
        <li><a href="/mysql/mysql-trans">事务相关</a></li>
        <li><a href="/mysql/other">其他</a></li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="/algo/">算法</a>
</li>
<li class="nav-dropdown-container resources">
  <a href="#" class="nav-link">Resources</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="/resources/partners.html" class="nav-link">Partners</a></li>
    <li><a href="/resources/themes.html" class="nav-link">Themes</a></li>
    <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank" rel="noopener">Awesome Vue</a></li>
    <li><a href="https://awesomejs.dev/for/vue/" class="nav-link" target="_blank" rel="noopener">Browse packages for Vue</a></li>
  </ul>
</li>

<!-- <li>
  <a href="/partners" class="nav-link ">Partners</a>
</li> -->
<li class="nav-dropdown-container support-vue">
  <a href="/support-vuejs/" class="nav-link">Support Vue</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="/support-vuejs/#One-time-Donations" class="nav-link">One-time Donations</a></li>
    <li><a href="/support-vuejs/#Recurring-Pledges" class="nav-link">Recurring Pledges</a></li>
    <li><a href="https://vue.threadless.com" target="_blank" rel="noopener" class="nav-link">T-Shirt Shop</a></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">Translations</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/os/index.html" class="nav-link">中文</a></li>
    <li><a target="_blank" rel="noopener" href="https://jp.vuejs.org/os/index.html" class="nav-link">日本語</a></li>
    <li><a target="_blank" rel="noopener" href="https://ru.vuejs.org/os/index.html" class="nav-link">Русский</a></li>
    <li><a target="_blank" rel="noopener" href="https://kr.vuejs.org/os/index.html" class="nav-link">한국어</a></li>
    <li><a target="_blank" rel="noopener" href="https://br.vuejs.org/os/index.html" class="nav-link">Português</a></li>
    <li><a target="_blank" rel="noopener" href="https://fr.vuejs.org/os/index.html" class="nav-link">Français</a></li>
    <li><a target="_blank" rel="noopener" href="https://vi.vuejs.org/os/index.html" class="nav-link">Tiếng Việt</a></li>
    <li><a target="_blank" rel="noopener" href="https://es.vuejs.org/os/index.html" class="nav-link">Español</a></li>
    <li><a target="_blank" rel="noopener" href="https://docs.vuejs.id/os/index.html" class="nav-link">Bahasa Indonesia</a></li>
  </ul>
</li>


    </ul>
  </header>
</div>

    
      <div id="main" class="fix-sidebar">
        
  <div class="sidebar">
    <ul class="main-menu">
      <li>
  <form id="search-form">
    <input type="text" id="search-query-sidebar" class="search-query st-default-search-input" aria-label="Search">
  </form>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link">⭐️Java</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Documentation</h4></li>
    <li>
      <ul>
        <li><a href="/java/oop/" class="nav-link">OOP</a></li>
        <li><a href="/v2/api" class="nav-link">API</a></li>
        <li><a href="/v2/style-guide" class="nav-link">Style Guide</a></li>
        <li><a href="/v2/examples" class="nav-link">Examples</a></li>
        <li><a href="/v2/cookbook" class="nav-link">Cookbook</a></li>
      </ul>
    </li>
    <li><h4>Video Courses</h4></li>
    <li>
      <ul>
        <li>
          <a href="https://www.vuemastery.com/courses/" class="nav-link" target="_blank" rel="sponsored noopener">
            Vue Mastery
          </a>
        </li>
        <li>
          <a
            href="https://vueschool.io/?friend=vuejs&utm_source=Vuejs.org&utm_medium=Link&utm_content=Navbar%20Dropdown"
            class="nav-link"
            target="_blank" rel="sponsored noopener"
          >
            Vue School
          </a>
        </li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container learn">
  <a class="nav-link">网络</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <!-- <li><h4>Documentation</h4></li> -->
    <li>
      <ul>
        <li><a href="/network">Review List</a></li>
        <li><a href="/network/tcp/">🔥TCP</a></li>
        <li><a href="/network/http/">HTTP</a></li>
        <li><a href="/network/ip/">IP</a></li>
      </ul>
    </li>
    <li><h4>Video Courses</h4></li>
    <li>
      <ul>
        <li>
          <a href="https://www.vuemastery.com/courses/" class="nav-link" target="_blank" rel="sponsored noopener">
            Vue Mastery
          </a>
        </li>
        <li>
          <a
            href="https://vueschool.io/?friend=vuejs&utm_source=Vuejs.org&utm_medium=Link&utm_content=Navbar%20Dropdown"
            class="nav-link"
            target="_blank" rel="sponsored noopener"
          >
            Vue School
          </a>
        </li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="/os/">操作系统</a>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link">数据库</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <!-- <li><h4>Documentation</h4></li> -->
    <li>
      <ul>
        <li><a href="/mysql">Review List</a></li>
        <li><a href="/mysql/mysql-index">索引相关</a></li>
        <li><a href="/mysql/mysql-index-operation">索引操作相关</a></li>
        <li><a href="/mysql/mysql-lock">锁相关</a></li>
        <li><a href="/mysql/mysql-logs">日志相关</a></li>
        <li><a href="/mysql/mysql-mvcc">MVCC</a></li>
        <li><a href="/mysql/mysql-trans">事务相关</a></li>
        <li><a href="/mysql/other">其他</a></li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="/algo/">算法</a>
</li>
<li class="nav-dropdown-container resources">
  <a href="#" class="nav-link">Resources</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="/resources/partners.html" class="nav-link">Partners</a></li>
    <li><a href="/resources/themes.html" class="nav-link">Themes</a></li>
    <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank" rel="noopener">Awesome Vue</a></li>
    <li><a href="https://awesomejs.dev/for/vue/" class="nav-link" target="_blank" rel="noopener">Browse packages for Vue</a></li>
  </ul>
</li>

<!-- <li>
  <a href="/partners" class="nav-link ">Partners</a>
</li> -->
<li class="nav-dropdown-container support-vue">
  <a href="/support-vuejs/" class="nav-link">Support Vue</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="/support-vuejs/#One-time-Donations" class="nav-link">One-time Donations</a></li>
    <li><a href="/support-vuejs/#Recurring-Pledges" class="nav-link">Recurring Pledges</a></li>
    <li><a href="https://vue.threadless.com" target="_blank" rel="noopener" class="nav-link">T-Shirt Shop</a></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">Translations</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/os/index.html" class="nav-link">中文</a></li>
    <li><a target="_blank" rel="noopener" href="https://jp.vuejs.org/os/index.html" class="nav-link">日本語</a></li>
    <li><a target="_blank" rel="noopener" href="https://ru.vuejs.org/os/index.html" class="nav-link">Русский</a></li>
    <li><a target="_blank" rel="noopener" href="https://kr.vuejs.org/os/index.html" class="nav-link">한국어</a></li>
    <li><a target="_blank" rel="noopener" href="https://br.vuejs.org/os/index.html" class="nav-link">Português</a></li>
    <li><a target="_blank" rel="noopener" href="https://fr.vuejs.org/os/index.html" class="nav-link">Français</a></li>
    <li><a target="_blank" rel="noopener" href="https://vi.vuejs.org/os/index.html" class="nav-link">Tiếng Việt</a></li>
    <li><a target="_blank" rel="noopener" href="https://es.vuejs.org/os/index.html" class="nav-link">Español</a></li>
    <li><a target="_blank" rel="noopener" href="https://docs.vuejs.id/os/index.html" class="nav-link">Bahasa Indonesia</a></li>
  </ul>
</li>


    </ul>
  </div>

<div class="content  ">
  <p class="tip warning v3-warning">
    Welcome to yanliang's notes.
  </p>

  
  
  
    <p>[TOC]</p>
<h2 id="简述自旋锁与互斥锁的使用场景"><a href="#简述自旋锁与互斥锁的使用场景" class="headerlink" title="简述自旋锁与互斥锁的使用场景"></a>简述自旋锁与互斥锁的使用场景</h2><p>互斥锁存在的问题是， 线程的休眠和唤醒都是相当昂贵的操作， 它们需要大量的CPU指令， 因此需要花费一些时间。 如果互斥量仅仅被锁住很短的一段时间， 用来使线程休眠和唤醒线程的时间会比该线程睡眠的时间还长， 甚至有可能比不断在自旋锁上轮训的时间还长。自旋锁的问题是， 如果自旋锁被持有的时间过长， 其它尝试获取自旋锁的线程会一直轮训自旋锁的状态， 这将非常浪费CPU的执行时间， 这时候该线程睡眠会是一个更好的选择。</p>
<p>线程lock mutex失败sleep到最后wakeup，线程陷入sleep和wakeup会消耗一些额外的cpu指令。<br>mutex本身是一个内核对象，lock/unlock时都会用system call。而system call本身会占用至少几百个时钟周期，大概几微秒。</p>
<p>spinlock没有这些额外消耗，但是不停轮询过程会消耗一些额外的cpu指令。</p>
<p>在多核机器中，如果锁住的“事务”很简单，占用很少的时间，就应该使用spinlock，这个时候spinlock的代价比mutex会小很多。”事务”很快执行完毕，自旋的消耗远远小于陷入sleep和wake的消耗。如果锁住“事务”粒度较大，就应该使用mutex，因为如果用spinlock，那么在“事务”执行过程中自旋很长时间还不如使得线程sleep。</p>
<p>在单核机器中。spinlock没有任何意义的，spinlock只会浪费唯一核心的cpu时间片，这个时刻没有任何线程会运行的。所以单核机器中，不论锁住的”事务”的粒度大小都要使用互斥锁</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">https://tech.meituan.com/2018/11/15/java-lock.html</a></p>
<h2 id="简述同步与异步的区别，阻塞与非阻塞的区别"><a href="#简述同步与异步的区别，阻塞与非阻塞的区别" class="headerlink" title="简述同步与异步的区别，阻塞与非阻塞的区别"></a>简述同步与异步的区别，阻塞与非阻塞的区别</h2><p>同步和异步关注的是消息通信机制。</p>
<p>所谓同步，就是在发起一次调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就要得到返回值。</p>
<p>异步：异步则恰恰相反，调用发出之后，这次调用就直接返回了。所以没有返回值。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</p>
<p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<h2 id="多线程和多进程的区别是什么？"><a href="#多线程和多进程的区别是什么？" class="headerlink" title="多线程和多进程的区别是什么？"></a>多线程和多进程的区别是什么？</h2><p><a target="_blank" rel="noopener" href="https://www.php.cn/faq/416853.html">https://www.php.cn/faq/416853.html</a></p>
<h2 id="两个线程交替打印一个共享变量"><a href="#两个线程交替打印一个共享变量" class="headerlink" title="两个线程交替打印一个共享变量"></a>两个线程交替打印一个共享变量</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/x541211190/article/details/109402864">https://blog.csdn.net/x541211190/article/details/109402864</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000037495406">https://segmentfault.com/a/1190000037495406</a></p>
<h2 id="简述-select-poll-epoll-的使用场景以及区别，epoll-中水平触发以及边缘触发有什么不同？"><a href="#简述-select-poll-epoll-的使用场景以及区别，epoll-中水平触发以及边缘触发有什么不同？" class="headerlink" title="简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？"></a>简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？</h2><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/9166944.html">https://www.cnblogs.com/aspirant/p/9166944.html</a></p>
<h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>阻塞 I/O，是指进程发起调用后，会被挂起（阻塞），直到收到数据再返回。如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞 I/O 时，需要使用多线程来处理多个文件描述符。</p>
<h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p>多线程切换有一定的开销，因此引入非阻塞 I/O。非阻塞 I/O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在一个线程里轮询多个文件描述符是否就绪。</p>
<p>但是非阻塞 I/O 的缺点是：每次发起系统调用，只能检查一个文件描述符是否就绪。当文件描述符很多时，系统调用的成本很高。</p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>
<p>select，poll，epoll都是IO多路复用的机制。</p>
<p>epoll和select都能提供I/O多路复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p>
<p>因此引入了 I/O 多路复用，可以<strong>通过一次系统调用，检查多个文件描述符的状态</strong>。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。</p>
<blockquote>
<p> I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了内核中，由内核来负责轮询。</p>
</blockquote>
<p>进程可以通过 select、poll、epoll 发起 I/O 多路复用的系统调用，这些系统调用都是同步阻塞的：如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后，再返回。使用非阻塞 I/O 检查每个描述符的就绪状态。</p>
<p>如果 <code>timeout</code> 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 <code>timeout</code> 参数设为 0，会立即返回，不阻塞。</p>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p>
<p><strong>缺点</strong></p>
<ol>
<li>单个进程可以监视 fd 数量被限制，能监听端口的大小也有限制</li>
<li>对 fd 进行线性扫描，即采用轮训的方式，效率低</li>
<li>需要维护一个用来存在大量fd的数据结构，这样会使得用户空间向内核空间传递该结构时开销过大。</li>
</ol>
<h3 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h3><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.</p>
<ol>
<li>大量的fd数据被整体复制与用户态和内核态之间</li>
<li>poll 还有一个特点是 <strong>水平触发</strong> 如果报告了fd之后，没有被处理，那么下次poll时会再次报告该fd</li>
</ol>
<h3 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h3><p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></p>
<p>epoll 有两种触发模式：水平触发和边缘触发。默认是水平触发。该模式下，只要fd还有数据可读，每次都会返回他的事件，提醒用户线程去操作。 而边缘触发模式，它只会触发一次，直到下一次在有数据流入之前都不会再提示，无论fd中是否有数据可读。，所以边缘触发模式下，读一个fd的时候一定要把他buffer读光。</p>
<ol>
<li>没有最大并发连接的限制，能打开的fd 的上限远大于 1024</li>
<li>效率提升，不是轮询的方式，不会随着fd数目的增加而效率降低</li>
</ol>
<p>Epoll最大的优点就在于它只管你 <code>活跃</code> 的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p>
<h3 id="为什么epoll-要有边缘触发模式"><a href="#为什么epoll-要有边缘触发模式" class="headerlink" title="为什么epoll 要有边缘触发模式"></a>为什么epoll 要有边缘触发模式</h3><p>如果采用水平触发模式的话，系统中一旦有大量不需要读写的就绪文件描述符时，他们每次都会返回，大大降低处理程序检索自己所关系的就绪文件描述符的效率。而边缘触发每次就绪时只会触发一次，这种模式比水平触发效率高，系统不会充斥大量你不关系的就绪文件描述符。</p>
<h3 id="什么是文件描述符-fd"><a href="#什么是文件描述符-fd" class="headerlink" title="什么是文件描述符 fd"></a>什么是文件描述符 fd</h3><p>文件描述符（file descriptor）是一个非负整数，从 0 开始。进程使用文件描述符来标识一个打开的文件。</p>
<p>系统为每一个进程维护了一个文件描述符表，表示该进程打开文件的记录表，而<strong>文件描述符实际上就是这张表的索引</strong>。当进程打开（<code>open</code>）或者新建（<code>create</code>）文件时，内核会在该进程的文件列表中新增一个表项，同时返回一个文件描述符 —— 也就是新增表项的下标。</p>
<p>一般来说，每个进程最多可以打开 64 个文件，<code>fd ∈ 0~63</code>。在不同系统上，最多允许打开的文件个数不同，Linux 2.4.22 强制规定最多不能超过 1,048,576。</p>
<h3 id="socket-和-fd-的关系"><a href="#socket-和-fd-的关系" class="headerlink" title="socket 和 fd 的关系"></a>socket 和 fd 的关系</h3><p>socket 是 Unix 中的术语。socket 可以用于同一台主机的不同进程间的通信，也可以用于不同主机间的通信。一个 socket 包含地址、类型和通信协议等信息，通过 <code>socket()</code> 函数创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol)</span><br></pre></td></tr></table></figure>

<p>返回的就是这个 socket 对应的文件描述符 <code>fd</code>。</p>
<p>可以这样理解：<strong>socket 是进程间通信规则的高层抽象，而 fd 提供的是底层的具体实现</strong>。socket 与 fd 是一一对应的。<strong>通过 socket 通信，实际上就是通过文件描述符 <code>fd</code> 读写文件</strong>。这也符合 Unix“一切皆文件”的哲学。</p>
<h2 id="简述-Linux-进程调度的算法"><a href="#简述-Linux-进程调度的算法" class="headerlink" title="简述 Linux 进程调度的算法"></a>简述 Linux 进程调度的算法</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<p><strong>先来先服务 first-come first-serverd（FCFS）</strong></p>
<p>非抢占式的调度算法，按照进程就绪的先后顺序使用CPU</p>
<p>优缺点：</p>
<ul>
<li>公平</li>
<li>实现简单</li>
<li>用户体验不友好（长进程后面的短进程需要等待时间较久）</li>
</ul>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>短作业优先 shortest job first（SJF）</strong></p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<p>优缺点：</p>
<ul>
<li>最短的平均周转时间</li>
<li>不公平（饥饿现象）</li>
</ul>
<p><strong>最高响应比优先 Highest Response Ratio Next</strong></p>
<p>是一个综合的算法，</p>
<p>调用时，首先计算每个进程的响应比R，然后按照响应比的大小来决定进程的执行顺序。</p>
<p>响应比的计算公式：</p>
<p>响应比R = 周转时间/处理时间 = （处理时间+等待时间） / 处理时间 = 1 + （等待时间/处理时间）</p>
<h3 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<p>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。</p>
<p>如何选择合适的时间片？</p>
<p>太长 - 退化为FIFO，延长短进程的响应时间<br>太短 - 进程切换浪费cup时间<br>经验值：10ms  –  100ms</p>
<p>优缺点：</p>
<ul>
<li>公平</li>
<li>有利于交互计算，响应时间快</li>
<li>由于进程切换，开销大</li>
<li>有利于大小不同的进程，不利于大小相同的进程（平均执行时间延长）</li>
</ul>
<p><strong>最高优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<p><strong>最短进程优先</strong></p>
<p>类似短作业优先</p>
<h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="什么时候会由用户态陷入内核态？"><a href="#什么时候会由用户态陷入内核态？" class="headerlink" title="什么时候会由用户态陷入内核态？"></a>什么时候会由用户态陷入内核态？</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bakari/p/5520860.html">https://www.cnblogs.com/bakari/p/5520860.html</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/69554144">https://zhuanlan.zhihu.com/p/69554144</a></p>
<p><img src="../img/os/1.png"></p>
<p>如上图所示，从宏观上来看，Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。</p>
<p>内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即<strong>系统调用</strong>。</p>
<p>系统调用是操作系统的最小功能单位，这些系统调用根据不同的应用场景可以进行扩展和裁剪，现在各种版本的Unix实现都提供了不同数量的系统调用.</p>
<blockquote>
<p>如Linux的不同版本提供了240-260个系统调用，FreeBSD大约提供了320个（reference：UNIX环境高级编程）。</p>
</blockquote>
<p>我们可以把系统调用看成是一种不能再化简的操作（类似于原子操作，但是不同概念），在进行一些复杂操作时（给某个变量分配内存空间），就必须调用很多的系统调用。</p>
<p>如果从实现者（程序员）的角度来看，这势必会加重程序员的负担，良好的程序设计方法是：重视上层的业务逻辑操作，而尽可能避免底层复杂的实现细节。<strong>库函数</strong>正是为了将程序员从复杂的细节中解脱出来而提出的一种有效方法。它实现对系统调用的封装，将简单的业务逻辑接口呈现给用户，方便用户调用。库函数依据不同的标准也可以有不同的实现版本，如ISO C 标准库，POSIX标准库等。</p>
<p>Shell是一个特殊的应用程序，俗称命令行，本质上是一个命令解释器，它下通系统调用，上通各种应用，通常充当着一种“胶水”的角色，来连接各个小功能程序，让不同程序能够以一个清晰的接口协同工作，从而增强各个程序的功能。</p>
<p>同时，Shell是可编程的，它可以执行符合Shell语法的文本，这样的文本称为Shell脚本，通常短短的几行Shell脚本就可以实现一个非常大的功能，原因就是这些Shell语句通常都对系统调用做了一层封装。</p>
<p>为了方便用户和系统交互，一般，一个Shell对应一个终端，终端是一个硬件设备，呈现给用户的是一个图形化窗口。我们可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。</p>
<p>用户态的应用程序可以通过三种方式来访问内核态的资源：</p>
<ol>
<li>系统调用</li>
<li>库函数</li>
<li>Shell脚本</li>
</ol>
<p><strong>用户态和内核态的切换</strong></p>
<p>因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。</p>
<p>所以，为了减少有限资源的访问和使用冲突，Unix/Linux的设计哲学之一就是：对不同的操作赋予不同的执行等级，就是所谓特权的概念。简单说就是有多大能力做多大的事，与系统相关的一些特别关键的操作必须由最高特权的程序来完成。</p>
<p>Intel的X86架构的CPU提供了0到3四个特权级，数字越小，特权越高，Linux操作系统中主要采用了0和3两个特权级，分别对应的就是内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。</p>
<p>很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存，当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换，类似的函数还有printf()，调用的是wirte()系统调用来输出字符串，等等。</p>
<ol>
<li>系统调用</li>
<li>异常事件： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</li>
<li>外围设备的中断：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</li>
</ol>
<p>注意：<strong>系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断</strong>，这是操作系统为用户特别开放的一种中断，如Linux int 80h中断。所以，从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</p>
<h2 id="简述几个常用的-Linux-命令以及他们的功能"><a href="#简述几个常用的-Linux-命令以及他们的功能" class="headerlink" title="简述几个常用的 Linux 命令以及他们的功能"></a>简述几个常用的 Linux 命令以及他们的功能</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ljianhui/article/details/11100625">https://blog.csdn.net/ljianhui/article/details/11100625</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009532290">https://segmentfault.com/a/1190000009532290</a></p>
<ul>
<li><input disabled="" type="checkbox"> 操作系统如何申请以及管理内存的？</li>
<li><input disabled="" type="checkbox"> 操作系统中，虚拟地址与物理地址之间如何映射？</li>
<li><input disabled="" type="checkbox"> </li>
<li><input disabled="" type="checkbox"> 简述操作系统中的缺页中断</li>
<li><input disabled="" type="checkbox"> 简述 Linux 系统态与用户态，什么时候会进入系统态？</li>
</ul>
<h2 id="进程通信中的管道实现原理是什么？"><a href="#进程通信中的管道实现原理是什么？" class="headerlink" title="进程通信中的管道实现原理是什么？"></a>进程通信中的管道实现原理是什么？</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009528245">https://segmentfault.com/a/1190000009528245</a></p>
<h2 id="Linux-下如何排查-CPU-以及-内存占用过多？"><a href="#Linux-下如何排查-CPU-以及-内存占用过多？" class="headerlink" title="Linux 下如何排查 CPU 以及 内存占用过多？"></a>Linux 下如何排查 CPU 以及 内存占用过多？</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40907977/article/details/102912861">https://blog.csdn.net/qq_40907977/article/details/102912861</a></p>
<h3 id="CPU-问题排查"><a href="#CPU-问题排查" class="headerlink" title="CPU 问题排查"></a>CPU 问题排查</h3><p>CPU 异常原因包括业务逻辑问题(死循环)、频繁gc以及上下文切换过多。而最常见的往往是业务逻辑(或者框架逻辑)导致的，可以使用jstack来分析对应的堆栈情况。<br>使用 jstack 分析 CPU 问题</p>
<ol>
<li>找到问题进程PID：通过top找到问题进程，例如下面有个进程CPU占用率高达99%，他的PID=270973。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 270973 worker    20   0 7166968 1.537g   3684 S   99.0 50.5  86501:25 java</span><br><span class="line">1285003 root      20   0 14.107g 4.651g   5664 S   0  0.4 762:10.25 java</span><br><span class="line">2805995 root      20   0  9.829g 2.587g   4604 S   0  0.1   3061:22 java</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>找到问题线程PID：通过top -p 270973 -H查找问题线程。（其中-p 270973表示查找指定进程270973的信息，-H表示线程模式。）经对比，发现问题线程的PID=2447223。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">2447223 root      20   0 3819540 1.319g   5960 S  80.3 42.1 121:25.99 ydbot-client</span><br><span class="line">2447225 root      20   0 3819540 1.319g   5960 S  0.3  2.1  27:41.90 ydbot-client</span><br><span class="line">2447230 root      20   0 3819540 1.319g   5960 S  0.3  2.1  27:57.98 ydbot-client</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将线程PID转换为nid：线程的nid是十六进制的，在linux系统中，通过shell命令printf将PID进行转换：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ printf 0x%x 2447223</span><br><span class="line">0x255777</span><br></pre></td></tr></table></figure>

<p>其中0x%x的0x是固定字符串，%x是printf的十六进制的转换类型。</p>
<ol start="4">
<li>后续通过jstack等工具进行分析</li>
</ol>
<p>jstack -l 11 |grep 0x255777</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@103-17-208-lg-201-k08 services]# jstack -l 11 |grep 0x255777</span><br><span class="line">2019-09-10 16:18:51</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.73-b02 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #18769 daemon prio&#x3D;9 os_prio&#x3D;0 tid&#x3D;0x00007f64dc0d4000 nid&#x3D;0x255777 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line">&quot;Keep-Alive-Timer&quot; #18768 daemon prio&#x3D;8 os_prio&#x3D;0 tid&#x3D;0x00007f64c83b8000 nid&#x3D;0x255777 waiting on condition [0x00007f63ec6e7000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at sun.net.www.http.KeepAliveCache.run(KeepAliveCache.java:172)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>

<p>通常我们会比较关注 WAITING 和 TIMED_WAITING 的部分，BLOCKED 就不用说了。我们可以使用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat jstack.log | grep &quot;java.lang.Thread.State&quot; | sort -nr | uniq -c</span><br></pre></td></tr></table></figure>

<h3 id="内存占用分析"><a href="#内存占用分析" class="headerlink" title="内存占用分析"></a>内存占用分析</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018553950">https://segmentfault.com/a/1190000018553950</a></p>
<ol>
<li>使用 cat /proc/meminfo 查看系统内存配置信息</li>
</ol>
<p>我们比较关心的是下面几个字段：</p>
<ul>
<li>MemTotal：系统总内存，由于 BIOS、内核等会占用一些内存，所以这里和配置声称的内存会有一些出入，比如我这里配置有 2G，但其实只有 1.95G 可用。</li>
<li>MemFree：系统空闲内存。</li>
<li>MemAvailable：应用程序可用内存。有人会比较奇怪和 MemFree 的区别，可以从两个层面来区分，MemFree 是系统层面的，而 MemAvailable 是应用程序层面的。系统中有些内存虽然被使用了但是有一部分是可以回收的，比如 Buffers、Cached 及 Slab 这些内存，这部分可以回收的内存加上 MemFree 才是 MemAvailable 的内存值，这是内核通过特定算法算出来的，是一个估算值。</li>
<li>Buffers：缓冲区内存</li>
<li>Cached：缓存</li>
</ul>
<ol start="2">
<li>使用 free 命令来查看系统当前内存使用情况</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:       32927536    14712632     2784440      493132    15430464    17319008</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure>

<p>MemTotal = used + free + buff/cache（单位 K）</p>
<p>shared 字段，这个是多进程的共享内存空间，不常用。</p>
<p>我们注意到 free 很小，buff/cache 却很大，这是 Linux 的内存设计决定的，Linux 的想法是内存闲着反正也是闲着，不如拿出来做系统缓存和缓冲区，提高数据读写的速率。但是当系统内存不足时，buff/cache 会让出部分来，非常灵活的操作。</p>
<p>要看比较直观的值，可以加 -h 参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:            31G         13G        4.0G        481M         13G         16G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure>

<p><strong>进程内存使用情况分析</strong></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018553950">https://segmentfault.com/a/1190000018553950</a></p>
<p>最常用的两个命令 ps 和 top</p>
<p>使用top命令，之后按照内存使用情况进行排序。</p>
<p>然后这里我们会重点关注几个地方，上面横排区，和前面几个命令一样可以查看系统内存信息，中间标注的横条部分，和内存相关的有三个字段：VIRT、RES、SHR。</p>
<ul>
<li>VIRT：virtual memory usage，进程占用的虚拟内存大小。</li>
<li>RES：resident memory usage，进程常驻内存大小，也就是实际内存占用情况，一般我们看进程占用了多少内存，就是看的这个值。</li>
<li>SHR：shared memory，共享内存大小，不常用。</li>
</ul>
<p>ps 同样可以查看进程占用内存情况，一般常用来查看 Top n 进程占用内存情况，如：<br>ps aux –sort=rss | head -n，表示按 rss 排序，取 Top n。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@phoenix-website-58b695b97d-gqzhw:&#x2F;app&#x2F;website# ps aux --sort&#x3D;rss | head -10</span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.0  0.0   1120     4 ?        Ss   06:39   0:00 &#x2F;sbin&#x2F;docker-init -- docker-entrypoint.sh npx docusaurus start --host 0.0.0.0</span><br><span class="line">root         48  0.0  0.0   4268    84 pts&#x2F;0    S+   09:54   0:00 &#x2F;bin&#x2F;sh -c TERM&#x3D;xterm-256color; export TERM; [ -x &#x2F;bin&#x2F;bash ] &amp;&amp; ([ -x &#x2F;usr&#x2F;bin&#x2F;script ] &amp;&amp; &#x2F;usr&#x2F;bin&#x2F;script -q -c &quot;&#x2F;bin&#x2F;bash&quot; &#x2F;dev&#x2F;null || exec &#x2F;bin&#x2F;bash) || exec &#x2F;bin&#x2F;sh</span><br><span class="line">root         60  0.0  0.0   4268    88 pts&#x2F;2    S+   11:02   0:00 &#x2F;bin&#x2F;sh -c TERM&#x3D;xterm-256color; export TERM; [ -x &#x2F;bin&#x2F;bash ] &amp;&amp; ([ -x &#x2F;usr&#x2F;bin&#x2F;script ] &amp;&amp; &#x2F;usr&#x2F;bin&#x2F;script -q -c &quot;&#x2F;bin&#x2F;bash&quot; &#x2F;dev&#x2F;null || exec &#x2F;bin&#x2F;bash) || exec &#x2F;bin&#x2F;sh</span><br><span class="line">root         73  0.0  0.0   4188   348 pts&#x2F;3    S+   11:10   0:00 head -10</span><br><span class="line">root         62  0.0  0.0   4268   364 pts&#x2F;3    Ss   11:02   0:00 sh -c &#x2F;bin&#x2F;bash</span><br><span class="line">root         50  0.0  0.0   4268   368 pts&#x2F;1    Ss   09:54   0:00 sh -c &#x2F;bin&#x2F;bash</span><br><span class="line">root         43  0.0  0.0   4268   624 pts&#x2F;0    Ss+  09:54   0:00 &#x2F;bin&#x2F;sh -c TERM&#x3D;xterm-256color; export TERM; [ -x &#x2F;bin&#x2F;bash ] &amp;&amp; ([ -x &#x2F;usr&#x2F;bin&#x2F;script ] &amp;&amp; &#x2F;usr&#x2F;bin&#x2F;script -q -c &quot;&#x2F;bin&#x2F;bash&quot; &#x2F;dev&#x2F;null || exec &#x2F;bin&#x2F;bash) || exec &#x2F;bin&#x2F;sh</span><br><span class="line">root         55  0.0  0.0   4268   628 pts&#x2F;2    Ss+  11:02   0:00 &#x2F;bin&#x2F;sh -c TERM&#x3D;xterm-256color; export TERM; [ -x &#x2F;bin&#x2F;bash ] &amp;&amp; ([ -x &#x2F;usr&#x2F;bin&#x2F;script ] &amp;&amp; &#x2F;usr&#x2F;bin&#x2F;script -q -c &quot;&#x2F;bin&#x2F;bash&quot; &#x2F;dev&#x2F;null || exec &#x2F;bin&#x2F;bash) || exec &#x2F;bin&#x2F;sh</span><br><span class="line">root         49  0.0  0.0  18920   880 pts&#x2F;0    S+   09:54   0:00 &#x2F;usr&#x2F;bin&#x2F;script -q -c &#x2F;bin&#x2F;bash &#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>

<p>这里也关注三个字段：</p>
<ul>
<li>%MEM：进程使用物理内存所占百分比。</li>
<li>VSZ：进程使用虚拟内存大小。</li>
<li>RSS：进程使用物理内存大小，我们会重点关注这个值。</li>
</ul>
<h2 id="简述操作系统如何进行内存管理"><a href="#简述操作系统如何进行内存管理" class="headerlink" title="简述操作系统如何进行内存管理"></a>简述操作系统如何进行内存管理</h2><h2 id="Linux-下如何查看端口被哪个进程占用？"><a href="#Linux-下如何查看端口被哪个进程占用？" class="headerlink" title="Linux 下如何查看端口被哪个进程占用？"></a>Linux 下如何查看端口被哪个进程占用？</h2><p>1、lsof -i:端口号<br>2、netstat -tunlp|grep 端口号</p>
<p>lsof -i 用以显示符合条件的进程情况，lsof(list open files)是一个列出当前系统打开文件的工具。以root用户来执行lsof -i命令<br>lsof -i:端口号，用于查看某一端口的占用情况，比如查看22号端口使用情况，lsof -i:22</p>
<p>netstat -tunlp用于显示tcp，udp的端口和进程等相关情况<br>netstat -tunlp|grep 端口号，用于查看指定端口号的进程情况，如查看22端口的情况，netstat -tunlp|grep 22</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fps2tao/p/10042553.html">https://www.cnblogs.com/fps2tao/p/10042553.html</a></p>
<ul>
<li><input disabled="" type="checkbox"> 简述 Linux 虚拟内存的页面置换算法</li>
</ul>
<p>地址重定向（地址转换、地址映射、地址翻译）：</p>

  
  
  <div class="footer">
      <script src="//m.servedby-buysellads.com/monetization.js" type="text/javascript"></script>
<div id="bsa-native"></div>
<script>
_bsa.init('custom', 'CKYD62QM', 'placement:vuejsorg',
  {
    target: '#bsa-native',
    template: '<a class="native-box" href="##statlink##"><div class="native-sponsor">Sponsor</div><div class="native-text"><strong>##company##</strong> — ##description##</div></a>'
  }
);
</script>


    Caught a mistake or want to contribute to the documentation?
    <a href="https://github.com/vuejs/vuejs.org/blob/master/src/os/index.md" rel="noopener" target="_blank">
      Edit this on GitHub!
    </a>
    <!-- Deployed on
    <a href="https://url.netlify.com/HJ8X2mxP8" rel="noopener" target="_blank">
      Netlify
    </a>. -->
  </div>
</div>

      </div>
      <script src="/js/smooth-scroll.min.js"></script>
    

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="/js/css.escape.js"></script>
    <script src="/js/common.js"></script>

    <!-- search -->
    <link href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" rel='stylesheet' type='text/css'>
    
<link rel="stylesheet" href="/css/search.css">

    <script src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <script>
    [
      '#search-query-nav',
      '#search-query-sidebar',
      '#search-query-menu'
    ].forEach(function (selector) {
      if (!document.querySelector(selector)) return
      // search index defaults to v2
      var match = window.location.pathname.match(/^\/(v\d+)/)
      var version = match ? match[1] : 'v2'
      docsearch({
      appId: 'BH4D9OD16A',
      apiKey: '85cc3221c9f23bfbaa4e3913dd7625ea',
      indexName: 'vuejs',
      inputSelector: selector,
      algoliaOptions: { facetFilters: ["version:" + version] },
      autocompleteOptions: { hint: false, appendTo: 'body'}
      })
    })
    </script>
  </body>
</html>
