


<!DOCTYPE html>
<html lang="en" class="with-v3-banner">
  <head>
    <title>TCP — Notes</title>
    <meta charset="utf-8">
    <meta name="description" content="Notes - Personal review warehouse">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="alternate" hreflang="x-default" href="https://vuejs.org/network/tcp.html">
    <link rel="alternate" hreflang="zh" href="https://cn.vuejs.org/network/tcp.html">
    <link rel="alternate" hreflang="ja" href="https://jp.vuejs.org/network/tcp.html">
    <link rel="alternate" hreflang="ru" href="https://ru.vuejs.org/network/tcp.html">
    <link rel="alternate" hreflang="ko" href="https://kr.vuejs.org/network/tcp.html">
    <link rel="alternate" hreflang="pt-BR" href="https://br.vuejs.org/network/tcp.html">
    <link rel="alternate" hreflang="fr" href="https://fr.vuejs.org/network/tcp.html">
    <link rel="alternate" hreflang="es" href="https://es.vuejs.org/network/tcp.html">

    <meta property="og:type" content="article">
    <meta property="og:title" content="TCP — Notes">
    <meta property="og:description" content="Notes - Personal review warehouse">
    <meta property="og:image" content="https://vuejs.org//images/logo.png">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="TCP — Notes">
    <meta name="twitter:description" content="Notes - Personal review warehouse">
    <meta name="twitter:image" content="https://vuejs.org/images/logo.png">

    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/images/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/images/icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/images/icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/icons/favicon-16x16.png">
    <meta name="msapplication-TileImage" content="/images/icons/ms-icon-144x144.png">
    <link rel="icon" href="/images/logo.png" type="image/png">

    <meta name="msapplication-TileColor" content="#4fc08d">
    <meta name="theme-color" content="#4fc08d">

    <meta name="msapplication-config" content="browserconfig.xml">
    <link rel="manifest" href="/manifest.json">

    <link href="https://fonts.googleapis.com" rel="preconnect" crossorigin>
    <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
    <link href="https://maxcdn.bootstrapcdn.com" rel="preconnect" crossorigin>

    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Dosis:500&text=Vue.js&display=swap" rel="stylesheet">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="/js/vue.js"></script>

    

    <script>
      Vue.config.productionTip = false
      window.PAGE_TYPE = "api"
    </script>

    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-46852172-1', 'vuejs.org');
      ga('send', 'pageview');
    </script>

    <!-- vimeo analytics -->
    <script type="text/javascript" defer="defer" src="https://extend.vimeocdn.com/ga/72160148.js"></script>
  <meta name="generator" content="Hexo 5.4.0"></head>
  <body class="docs">
    <div id="mobile-bar" >
      <a class="menu-button"></a>
      <a class="logo" href="/"></a>
    </div>
    <div>
  <div id="v3-banner">
    <span class="hidden-sm">Welcome to yanliang's notes</span>
  </div>

  <header id="header">
    <a id="logo" href="/">
      <img src="/images/logo.png" alt="vue logo">
      <span>Notes - personal review warehouse</span>
    </a>
    <ul id="nav">
      <li>
  <form id="search-form">
    <input type="text" id="search-query-nav" class="search-query st-default-search-input" aria-label="Search">
  </form>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link">⭐️Java</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Documentation</h4></li>
    <li>
      <ul>
        <li><a href="/java/oop/" class="nav-link">OOP</a></li>
        <li><a href="/v2/api/" class="nav-link">API</a></li>
        <li><a href="/v2/style-guide/" class="nav-link">Style Guide</a></li>
        <li><a href="/v2/examples/" class="nav-link">Examples</a></li>
        <li><a href="/v2/cookbook/" class="nav-link">Cookbook</a></li>
      </ul>
    </li>
    <li><h4>Video Courses</h4></li>
    <li>
      <ul>
        <li>
          <a href="https://www.vuemastery.com/courses/" class="nav-link" target="_blank" rel="sponsored noopener">
            Vue Mastery
          </a>
        </li>
        <li>
          <a
            href="https://vueschool.io/?friend=vuejs&utm_source=Vuejs.org&utm_medium=Link&utm_content=Navbar%20Dropdown"
            class="nav-link"
            target="_blank" rel="sponsored noopener"
          >
            Vue School
          </a>
        </li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container learn">
  <a class="nav-link">网络</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <!-- <li><h4>Documentation</h4></li> -->
    <li>
      <ul>
        <li><a href="/network">Review List</a></li>
        <li><a href="/network/tcp/">🔥TCP</a></li>
        <li><a href="/network/http/">HTTP</a></li>
        <li><a href="/network/ip/">IP</a></li>
      </ul>
    </li>
    <li><h4>Video Courses</h4></li>
    <li>
      <ul>
        <li>
          <a href="https://www.vuemastery.com/courses/" class="nav-link" target="_blank" rel="sponsored noopener">
            Vue Mastery
          </a>
        </li>
        <li>
          <a
            href="https://vueschool.io/?friend=vuejs&utm_source=Vuejs.org&utm_medium=Link&utm_content=Navbar%20Dropdown"
            class="nav-link"
            target="_blank" rel="sponsored noopener"
          >
            Vue School
          </a>
        </li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="/os/">操作系统</a>
</li>
<li>
  <a href="/mysql/">💼数据库</a>
</li>
<li>
  <a target="_blank" rel="noopener" href="https://codetop.cc/#/home">❤️算法</a>
</li>
<li class="nav-dropdown-container resources">
  <a href="#" class="nav-link">Resources</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="/resources/partners.html" class="nav-link">Partners</a></li>
    <li><a href="/resources/themes.html" class="nav-link">Themes</a></li>
    <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank" rel="noopener">Awesome Vue</a></li>
    <li><a href="https://awesomejs.dev/for/vue/" class="nav-link" target="_blank" rel="noopener">Browse packages for Vue</a></li>
  </ul>
</li>

<!-- <li>
  <a href="/partners" class="nav-link ">Partners</a>
</li> -->
<li class="nav-dropdown-container support-vue">
  <a href="/support-vuejs/" class="nav-link">Support Vue</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="/support-vuejs/#One-time-Donations" class="nav-link">One-time Donations</a></li>
    <li><a href="/support-vuejs/#Recurring-Pledges" class="nav-link">Recurring Pledges</a></li>
    <li><a href="https://vue.threadless.com" target="_blank" rel="noopener" class="nav-link">T-Shirt Shop</a></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">Translations</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/network/tcp.html" class="nav-link">中文</a></li>
    <li><a target="_blank" rel="noopener" href="https://jp.vuejs.org/network/tcp.html" class="nav-link">日本語</a></li>
    <li><a target="_blank" rel="noopener" href="https://ru.vuejs.org/network/tcp.html" class="nav-link">Русский</a></li>
    <li><a target="_blank" rel="noopener" href="https://kr.vuejs.org/network/tcp.html" class="nav-link">한국어</a></li>
    <li><a target="_blank" rel="noopener" href="https://br.vuejs.org/network/tcp.html" class="nav-link">Português</a></li>
    <li><a target="_blank" rel="noopener" href="https://fr.vuejs.org/network/tcp.html" class="nav-link">Français</a></li>
    <li><a target="_blank" rel="noopener" href="https://vi.vuejs.org/network/tcp.html" class="nav-link">Tiếng Việt</a></li>
    <li><a target="_blank" rel="noopener" href="https://es.vuejs.org/network/tcp.html" class="nav-link">Español</a></li>
    <li><a target="_blank" rel="noopener" href="https://docs.vuejs.id/network/tcp.html" class="nav-link">Bahasa Indonesia</a></li>
  </ul>
</li>


    </ul>
  </header>
</div>

    
      <div id="main" class="fix-sidebar">
        
  

<div class="sidebar">
  <div class="sidebar-inner">
    
    <div class="list">
      <!-- <div id="sidebar-sponsors-special">
  <div class="main-sponsor">
    <span>Special Sponsor</span>
    <div>
    <a href="https://autocode.com/" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/autocode.svg" alt="Autocode">
    </a>
    </div>
  </div>
</div>

 -->
      
        <!-- <h2>
          
          API
          
            <select class="version-select">
              <option value="v3">3.x</option>
              <option value="SELF" selected>2.x</option>
              <option value="v1">1.0</option>
              <option value="012">0.12</option>
              <option value="011">0.11</option>
            </select>
          
        </h2> -->
        <ul class="menu-root">
  
</ul>

      
    </div>
  </div>
</div>
<!-- 
<div id="sidebar-sponsors-platinum-right">
  <div class="main-sponsor">
    <span>Platinum Sponsors</span>
    <div>
    <a href="https://vueschool.io/?utm_source=Vuejs.org&utm_medium=Banner&utm_campaign=Sponsored%20Banner&utm_content=V1" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/vueschool.png" alt="VueSchool">
    </a>
    <a href="https://vehikl.com/" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/vehikl.png" alt="Vehikl">
    </a>
    <a href="https://retool.com/?utm_source=sponsor&utm_campaign=vue" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/retool.png" alt="Retool">
    </a>
    <a href="https://passionatepeople.io/" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/passionate_people.png" alt="Passionate People">
    </a>
    <a href="https://www.storyblok.com" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/storyblok.png" alt="Storyblok">
    </a>
    <a href="https://ionicframework.com/vue?utm_source=partner&utm_medium=referral&utm_campaign=vuesponsorship&utm_content=vuedocs" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/ionic.png" alt="Ionic">
    </a>
    <a href="https://nuxtjs.org/" target="_blank" rel="sponsored noopener" class="logo">
      <img src="/images/nuxt.png" alt="Nuxt">
    </a>
    </div>
  </div>
  <a class="become-backer" href="/support-vuejs">
    Become a Sponsor
  </a>
</div>

 -->


<div class="content api with-sidebar ">
  <p class="tip warning v3-warning">
    Welcome to yanliang's notes.
  </p>

  
    
      
<div id="ad">
  <script
    async
    type="text/javascript"
    src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&placement=vuejsorg"
    id="_carbonads_js">
  </script>
</div>


    
  
  
    <h1>TCP</h1>
  
  
    <h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/14.png"></p>
<p>OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。 OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。</p>
<p>OSI 七层模型在提出时的出发点是基于标准化的考虑，而没有考虑到具体的市场需求，使得该模型结构复杂，部分功能冗余，因而完全实现 OSI 参考模型的系统不多。而 TCP/IP 参考模型直接面向市场需求，实现起来也比较容易，因此在一经提出便得到了广泛的应用。基于 TCP/IP 的参考模型将协议分成四个层次，如上图所示，它们分别是：网络访问层、网际互联层、传输层、和应用层。</p>
<p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p>
<p><strong>应用层</strong></p>
<p>应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用。该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。</p>
<p>例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。在应用层交互的数据单元我们称之为报文。</p>
<p><strong>表示层</strong></p>
<p>表示层的作用是使通信的应用程序能够解释交换数据的含义。该层提供的服务主要包括数据压缩，数据加密以及数据描述。这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。</p>
<p><strong>会话层</strong></p>
<p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</p>
<p><strong>传输层</strong></p>
<p>传输层的主要任务是为两台主机进程之间的通信提供服务。应用程序利用该服务传送应用层报文。该服务并不针对某一特定的应用，多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p><strong>网络层</strong></p>
<p>网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送。在发送数据时，网络层把运输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。</p>
<p><strong>数据链路层</strong></p>
<p>数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。</p>
<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。</p>
<p><strong>物理层</strong></p>
<p>物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。</p>
<h3 id="为什么网络要分层？"><a href="#为什么网络要分层？" class="headerlink" title="为什么网络要分层？"></a>为什么网络要分层？</h3><p><strong>网络分层的原则：</strong> 每一层独立于其它层完成自己的工作，而不需要相互依赖，上下层之间通过标准结构来互相通信，简单易用又具有拓展性。复杂的系统需要分层，因为每一层都需要专注于一类事情。我们的网络分层的原因也是一 样，每一层只专注于做一类事情。</p>
<h2 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h2><h3 id="TCP-与-UDP-属于那一层？-区别"><a href="#TCP-与-UDP-属于那一层？-区别" class="headerlink" title="TCP 与 UDP 属于那一层？ 区别"></a>TCP 与 UDP 属于那一层？ 区别</h3><p>传输层</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否面向连接</th>
<th>传输可靠性</th>
<th>传输形式</th>
<th>传输效率</th>
<th>所需资源</th>
<th>应用场景</th>
<th>首部字节</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>是</td>
<td>可靠</td>
<td>字节流</td>
<td>慢</td>
<td>多</td>
<td>文件传输、邮件传输</td>
<td>20~60</td>
</tr>
<tr>
<td>UDP</td>
<td>否</td>
<td>不可靠</td>
<td>数据报文段</td>
<td>快</td>
<td>少</td>
<td>即时通讯、域名转换</td>
<td>8 个字节</td>
</tr>
</tbody></table>
<ol>
<li>TCP 面向连接， UDP 面向非连接</li>
<li>TCP 提供可靠服务， UDP 不提供可靠服务</li>
<li>TCP 面向字节流， UDP 面向报文</li>
<li>TCP 数据传输慢， UDP 数据传送快</li>
</ol>
<p><strong>UDP的应用场景：</strong> 对当前网络通讯质量要求不高的时候，要求网络通讯速度尽量的快，这时就使用UDP。进行视频聊天或者看直播，可以使用UDP协议，因为即使几个画面丢失了，对用户来说影响也不是很大</p>
<p><strong>TCP的应用场景：</strong> 当对网络通信质量有要求时需要用TCP，发消息的场景以及文件传输，要确保发送的消息不丢失</p>
<h3 id="TCP-怎么保证可靠传输？"><a href="#TCP-怎么保证可靠传输？" class="headerlink" title="TCP 怎么保证可靠传输？"></a>TCP 怎么保证可靠传输？</h3><p>TCP协议保证数据传输可靠性的方式主要有：</p>
<ul>
<li>校验和</li>
<li>序列号</li>
<li>确认应答</li>
<li>超时重传</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1463613">https://cloud.tencent.com/developer/article/1463613</a></p>
<h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p> TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</p>
<h4 id="序列号与确认应答"><a href="#序列号与确认应答" class="headerlink" title="序列号与确认应答"></a>序列号与确认应答</h4><p>序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。</p>
<p>确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>
<p>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</p>
<h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。但是由于网络问题发送方可能收不到ACK响应。</p>
<p>发送方没有接收到ACK响应的原因有可能是如下两种：</p>
<ul>
<li>数据发送方：数据发送过程中有由于网络问题全体丢包，接收方根本没有收到数据。</li>
<li>数据接收方：数据拿到了。但是发送ACK报文的时候由于网络问题，发送失败</li>
</ul>
<p>TCP引入了<code>超时重传机制</code>来解决以上问题。简单的理解就是在发送方发送数据后的一段时候内，如果没有接收到接收方的ACK响应，那么刚刚发送的数据需要重新发送。</p>
<p>对应上面说到的两种原因，如果是数据发方的问题，数据重新发送，数据接收方进行响应ACK;如果是数据接收方的问题，数据发送过来之后，接收方根据序列号判断是否是重复数据，如果是直接丢弃，然后继续返回ack响应。</p>
<p>由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。 </p>
<p>重传机制还有以下几种：</p>
<p><strong>快速重传</strong></p>
<p>快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以数据驱动重传。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/4.png"></p>
<p>在上图，发送方发出了 1，2，3，4，5 份数据，第一份 Seq1 先送到了，于是就 Ack 回 2，结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2，后面的Seq4 &gt; 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到，发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢的 Seq2。</p>
<p>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</p>
<p>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。</p>
<p>比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p>
<p>为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法。</p>
<p><strong>SACK</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/5.png"></p>
<p><strong>Duplicate SACK</strong></p>
<p>Duplicate SACK 又称 D-SACK ，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/6.png"><br><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/7.png"></p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</p>
<p>拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。</p>
<p>TCP进行拥塞控制常用的算法有四种：<code>慢启动</code>、<code>拥塞避免</code>、<code>快重传</code>、<code>快恢复</code>。</p>
<p><strong>慢启动</strong></p>
<p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。TCP为发送方维持一个拥塞窗口，记为cwnd。拥塞窗口是发送方使用的流量控制，接收方声明的接收窗口是接收方使用的流量控制。发送方的发送窗口大小等于这两个窗口中的最小值。（发送窗口 swnd 、接收窗口 rwnd、swnd = min(cwnd, rwnd)）</p>
<p>拥塞窗口的值跟SMSS有关，SMSS为发送的最大报文段长度。</p>
<p>慢启动算法规定：拥塞窗口初始化后，每收到一个对新报文的确认，拥塞窗口就加一个SMSS的大小。拥塞窗口以字节为单位，但是慢启动以SMSS大小为单位增加。按照慢启动算法，经过一轮传输，拥塞窗口就增大一倍，这是一种指数增长的关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/8.png"></p>
<p>这里假定拥塞窗口 cwnd 和发送窗口 swnd 相等，下面举个栗子：</p>
<ul>
<li>连接建立完成后，一开始初始化 cwnd = 1 ，表示可以传一个 SMSS 大小的数据。</li>
<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li>
</ul>
<p><strong>拥塞避免</strong></p>
<p>慢启动算法除了维持拥塞窗口cwnd变量之外，还维持另一个变量慢启动门限ssthresh。当cwnd以指数增长的形式增长到大于或等于ssthresh时，就不再采用慢启动算法，而是采用拥塞避免算法来进行拥塞控制。</p>
<ul>
<li>当 cwnd &lt; ssthresh 时，使用慢启动算法。</li>
<li>当 cwnd &gt;= ssthresh 时，就会使用「拥塞避免算法」。 （一般来说 ssthresh 的大小是 65535 字节。）</li>
</ul>
<p>拥塞避免算法规定：每次收到一个确认时将cwnd增加 <code>1/cwnd</code> 个SMSS。即不再是像慢启动算法那样经过一轮传输cwnd翻倍了，而是经过一轮传输增加一个SMSS。这是一种加性增长的关系。</p>
<p>接上前面的慢启动的栗子，现假定 ssthresh 为 8 ,当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了线性增长</p>
<p><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/9.png"></p>
<p><strong>快重传</strong></p>
<p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：超时重传、快速重传。</p>
<p>当发生了「超时重传」，则就会使用拥塞发生算法。这个时候，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li>ssthresh 设为 cwnd/2 </li>
<li>cwnd 重置为1</li>
</ul>
<p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/10.png"></p>
<p>如果使用的是「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p>
<p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：</p>
<ul>
<li>cwnd = cwnd/2 ，也就是设置为原来的一半</li>
<li>ssthresh = cwnd</li>
<li>进入快速恢复算法</li>
</ul>
<p><strong>快恢复</strong></p>
<p>进入快速恢复之前， cwnd 和 ssthresh 已被更新了：</p>
<ul>
<li>cwnd = cwnd/2 ，也就是设置为原来的一半;</li>
<li>ssthresh = cwnd ;</li>
</ul>
<p>然后，进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/11.png"></p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>通过TCP连接发送数据，如果发送方发送数据很慢，容易造成资源浪费；如果发送方发送数据过快，接收方来不及接收会造成数据丢失。流量控制就是指在接收方能够接收的范围内，合理而又快速的发送数据。</p>
<p><strong>基于滑动窗口的流量控制</strong></p>
<p>利用滑动窗口机制可以实现对发送方的流量控制。在TCP连接建立时，接收方会在确认报文段中给出自己接收窗口的大小。在每次发送确认报文时能够根据情况动态调整接收窗口的大小，并将告知发送方。</p>
<p>在接收方接收窗口为0时，发送方不再发送数据，直到接收方发送确认报文表明窗口大小发生改变。可是这个确认报文不一定能够被发送方接收到，如果一旦该确认报文丢失，双方都将处于等待中，形成死锁。为防止这种情况出现，TCP规定在收到对方接受窗口为0时，启动一个坚持定时器周期性的发送探测报文，以确定对方接收窗口为0的状态是否改变。</p>
<p>另外，TCP标准规定：接收方接收窗口为0时，不再接收正常数据，但是可以接收零窗口探测报文段、确认报文段、携带紧急数据的报文段。</p>
<p><strong>糊涂窗口综合症</strong></p>
<p>当发送端应用进程产生数据很慢、或接收端应用进程处理接收缓冲区数据很慢，或二者兼而有之；就会使应用进程间传送的报文段很小，特别是有效载荷很小。 极端情况下，有效载荷可能只有1个字节；而传输开销有40字节(20字节的IP头+20字节的TCP头) 这种现象就叫糊涂窗口综合症。</p>
<p>避免糊涂窗口综合症可以从两端采取解决措施：</p>
<ol>
<li>防止发送端的TCP逐个字节地发送数据。必须强迫发送端的TCP收集数据，然后用一个更大的数据块来发送。  Nagle算法 </li>
<li>Clark 和 延迟ACK</li>
</ol>
<blockquote>
<p>Clark解决方法是只要有数据到达就发送确认，但宣布的窗口大小为零，直到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhaoyl/archive/2012/09/20/2695799.html">https://www.cnblogs.com/zhaoyl/archive/2012/09/20/2695799.html</a></p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>如果TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/12.png"></p>
<p>这样的传输方式有一个缺点：数据包的往返时间越长，通信的效率就越低。</p>
<p>为解决这个问题，TCP 引入了窗口这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。</p>
<p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<p>假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK丢失，可以通过「下一个确认应答进行确认」。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/13.png"></p>
<p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫累计确认或者累计应答。</p>
<h4 id="Ack-延迟确认机制"><a href="#Ack-延迟确认机制" class="headerlink" title="Ack 延迟确认机制"></a>Ack 延迟确认机制</h4><p>接收方在收到数据后，并不会立即回复ACK,而是延迟一定时间。一般ACK延迟发送的时间为200ms，但这个200ms并非收到数据后需要延迟的时间。系统有一个固定的定时器每隔200ms会来检查是否需要发送ACK包。这样做有两个目的。</p>
<ol>
<li>这样做的目的是ACK是可以合并的，也就是指如果连续收到两个TCP包，并不一定需要ACK两次，只要回复最终的ACK就可以了，可以降低网络流量。</li>
<li>如果接收方有数据要发送，那么就会在发送数据的TCP数据包里，带上ACK信息。这样做，可以避免大量的ACK以一个单独的TCP包发送，减少了网络流量。</li>
</ol>
<h3 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h3><p>ARQ协议，即自动重传请求（Automatic Repeat-reQuest）它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。</p>
<p>ARQ包括停止等待ARQ协议和连续ARQ协议，拥有错误检测（Error Detection）、正面确认（Positive Acknowledgment）、超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制。</p>
<h3 id="从系统层面上，UDP如何保证尽量可靠？"><a href="#从系统层面上，UDP如何保证尽量可靠？" class="headerlink" title="从系统层面上，UDP如何保证尽量可靠？"></a>从系统层面上，UDP如何保证尽量可靠？</h3><p> UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>实现确认机制、重传机制、窗口确认机制。</p>
<p>可以从以下两方面来实现：</p>
<ul>
<li>发送：包的分片、包确认、包的重发</li>
<li>接收：包的调序、包的序号确认</li>
</ul>
<p>目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/pangyemeng/article/details/50387078">https://blog.csdn.net/pangyemeng/article/details/50387078</a></p>
<h4 id="什么是-TCP-粘包和拆包？"><a href="#什么是-TCP-粘包和拆包？" class="headerlink" title="什么是 TCP 粘包和拆包？"></a>什么是 TCP 粘包和拆包？</h4><p>粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。</p>
<p>因为TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p>
<p><strong>常见的解决方案</strong></p>
<ul>
<li>发送端将每个包都封装成固定的长度，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度；</li>
<li>发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并；例如，FTP协议；</li>
<li>将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；</li>
<li>通过自定义协议进行粘包和拆包的处理。</li>
</ul>
<h4 id="TCP-的-keepalive-了解吗？说一说它和-HTTP-的-keep-alive-的区别？"><a href="#TCP-的-keepalive-了解吗？说一说它和-HTTP-的-keep-alive-的区别？" class="headerlink" title="TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keep-alive 的区别？"></a>TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keep-alive 的区别？</h4><p>TCP协议也叫传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。使用TCP的两个程序（客户端和服务端）在交换数据前，通过三次握手来建立TCP连接，建立连接后就可以进行基于字节流的双工通讯，由TCP内部实现保证通讯的可靠性，完全通讯完成后，通过四次挥手断开连接。</p>
<p>在客户端和服务端间的网络一切正常、且双方都没主动发起关闭连接的请求时，此TCP连接理论上可以永久保持。但是，网络情况是及其复杂的，在双方长时间未通讯时，如何得知对方还活着？如何得知这个TCP连接是健康且具有通讯能力的？</p>
<p>TCP的 <code>保活机制</code> 就是用来解决此类问题，这个机制我们也可以称作：<code>keepalive</code>。保活机制默认是关闭的，TCP连接的任何一方都可打开此功能。有三个主要配置参数用来控制保活功能。</p>
<p>如果在一段时间（保活时间：tcp_keepalive_time）内此连接都不活跃，开启保活功能的一端会向对端发送一个保活探测报文。</p>
<p>若对端正常存活，且连接有效，对端必然能收到探测报文并进行响应。此时，发送端收到响应报文则证明TCP连接正常，重置保活时间计数器即可。</p>
<p>若由于网络原因或其他原因导致，发送端无法正常收到保活探测报文的响应。那么在一定探测时间间隔（tcp_keepalive_intvl）后，将继续发送保活探测报文。直到收到对端的响应，或者达到配置的探测循环次数上限（tcp_keepalive_probes）都没有收到对端响应，这时对端会被认为不可达，TCP连接随存在但已失效，需要将连接做中断处理。</p>
<p>在探测过程中，对端主机会处于以下四种状态之一：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>处理</th>
</tr>
</thead>
<tbody><tr>
<td>对方主机仍在工作，并且可达</td>
<td>TCP 连接正常，将保活计时器重置。</td>
</tr>
<tr>
<td>对方主机已崩溃，包括：已关闭或者正在重启</td>
<td>TCP 连接不正常，经过指定次数的探测依然没得到响应，则断开连接</td>
</tr>
<tr>
<td>对方主机崩溃并且已经重启</td>
<td>重启后原连接已失效，对方由于不认识探测报文，会响应重置报文段，请求端将连接断开</td>
</tr>
<tr>
<td>对方主机仍在工作，但由于某些原因不可达（如：网络原因）</td>
<td>TCP 连接不正常，经过指定次数的探测依然没得到响应，则断开连接</td>
</tr>
</tbody></table>
<p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写。HTTP是万维网的数据通信的基础。HTTP是一个应用层协议，通常运行在TCP协议之上。它由请求和响应构成，是一个标准的客户端服务器模型（C/S模型）。HTTP是一个无状态的协议。</p>
<p>无状态怎么解释？HTTP协议永远都是客户端发起请求，服务器回送响应。每次连接只处理一个请求，当服务器返回本次请求的应答后便立即关闭连接，下次请求客户端再重新建立连接。也就无法实现在客户端没有发起请求的时候，服务器主动将消息推送给客户端。</p>
<p>无状态会导致客户端的每次请求都需要重新建立TCP连接，接受到服务端响应后，断开TCP连接。对于每次建立、断开TCP连接，还是有相当的性能损耗的。那么，如何才能尽可能的减少性能损耗呢？</p>
<p>HTTP 协议引入 <code>keep-alive</code> 机制来解决上述问题。http1.0默认是关闭的，通过http请求头设置“connection: keep-alive”进行开启；http1.1中默认开启，通过http请求头设置“connection: close”关闭。</p>
<p>keep-alive机制：若开启后，在一次http请求中，服务器进行响应后，不再直接断开TCP连接，而是将TCP连接维持一段时间。在这段时间内，如果同一客户端再次向服务端发起http请求，便可以复用此TCP连接，向服务端发起请求，并重置timeout时间计数器，在接下来一段时间内还可以继续复用。这样无疑省略了反复创建和销毁TCP连接的损耗。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/1.png"></p>
<ol>
<li><p>首先客户端向服务器发送一个 SYN 包，并等待服务器确认，其中：</p>
<ul>
<li>标志位为 SYN，表示请求建立连接；</li>
<li>序号为 Seq = x（x 一般为 1）；</li>
<li>随后客户端进入 SYN-SENT 阶段。</li>
</ul>
</li>
<li><p>服务器接收到客户端发来的 SYN 包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文，其中：</p>
<ul>
<li>标志位为 SYN 和 ACK，表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接；</li>
<li>序号为 Seq = y；</li>
<li>确认号为 Ack = x + 1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值，随后服务器端进入 SYN-RECV 阶段。</li>
</ul>
</li>
<li><p>客户端接收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文。其中：</p>
<ul>
<li>标志位为 ACK，表示确认收到服务器端同意连接的信号；</li>
<li>序号为 Seq = x + 1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；</li>
<li>确认号为 Ack= y + 1，表示收到服务器端序号 seq，并将其值加 1 作为自己的确认号 Ack 的值。</li>
<li>随后客户端进入 ESTABLISHED。</li>
</ul>
</li>
</ol>
<p>当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-RECV 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。</p>
<h3 id="第三次握手可以携带数据吗？"><a href="#第三次握手可以携带数据吗？" class="headerlink" title="第三次握手可以携带数据吗？"></a>第三次握手可以携带数据吗？</h3><p>TCP标准规定，第三次握手的报文，可以携带数据。因为此时客户端已经处于established状态了呀。</p>
<p>假设第三次握手的报文的seq是x+1，如果有携带数据，下次客户端发送的报文，seq=服务器发回的ACK号。</p>
<p>如果没有携带数据，那么第三次握手的报文不消耗seq。下次客户端发送的报文，seq序列号还是和第三次握手的报文的seq一样，为x+1。这是因为，seq和报文中的数据在整条数据流流中的位置是一一对应的。如果报文没有携带数据，那么seq当然也不会更新。</p>
<h3 id="如果三次握手的时候每次握手信息对方没有收到会怎么样"><a href="#如果三次握手的时候每次握手信息对方没有收到会怎么样" class="headerlink" title="如果三次握手的时候每次握手信息对方没有收到会怎么样"></a>如果三次握手的时候每次握手信息对方没有收到会怎么样</h3><p>若第一次握手服务器未接收到客户端请求建立连接的数据包时，服务器不会进行任何相应的动作，而客户端由于在一段时间内没有收到服务器发来的确认报文， 因此会等待一段时间后重新发送 SYN 同步报文，若仍然没有回应，则重复上述过程直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1。</p>
<p>若第二次握手客户端未接收到服务器回应的 ACK 报文时，客户端会采取第一次握手失败时的动作，这里不再重复，而服务器端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文。</p>
<p>若第三次握手服务器未接收到客户端发送过来的 ACK 报文，同样会采取类似于客户端的超时重传机制，若重传次数超过限制后仍然没有回应，则 accept() 系统调用返回 -1，服务器端连接建立失败。</p>
<p>但此时客户端认为自己已经连接成功了，因此开始向服务器端发送数据，但是服务器端的 accept() 系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会发送 RST 报文给 客户端，消除客户端单方面建立连接的状态</p>
<h3 id="为什么要进行三次握手？两次握手可以吗？"><a href="#为什么要进行三次握手？两次握手可以吗？" class="headerlink" title="为什么要进行三次握手？两次握手可以吗？"></a>为什么要进行三次握手？两次握手可以吗？</h3><p>三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据。</p>
<p>我们知道网络往往是非理想状态的（存在丢包和延迟），当客户端发起创建连接的请求时，如果服务器直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直接收不到返回的数据包。</p>
<p>由于客户端可能设置了一个超时时间，一段时间后就关闭了连接建立的请求，再重新发起新的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器客户端能否收到服务器传输的数据的话，服务器端的端口就会一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。长此以往， 这样的端口越来越多，就会造成服务器开销的浪费。</p>
<h3 id="第-2-次握手传回了-ACK，为什么还要传回-SYN"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN</h3><p>SYN是在建立连接时用到的同步信号。</p>
<p>ACK 是为了告诉客户端发来的数据已经接收无误，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的.</p>
<p>回传SYN则是为了建立并确认从服务端到客户端的通信。</p>
<h3 id="如果已经建立了连接，但客户端出现了故障怎么办？"><a href="#如果已经建立了连接，但客户端出现了故障怎么办？" class="headerlink" title="如果已经建立了连接，但客户端出现了故障怎么办？"></a>如果已经建立了连接，但客户端出现了故障怎么办？</h3><p>服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h3 id="TCP-中-SYN-攻击是什么？如何防止？"><a href="#TCP-中-SYN-攻击是什么？如何防止？" class="headerlink" title="TCP 中 SYN 攻击是什么？如何防止？"></a>TCP 中 SYN 攻击是什么？如何防止？</h3><p>在 TCP 建立连接的过程中，因为服务端不确定自己发给客户端的 SYN-ACK 消息或客户端反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接状态设一个定时器，如果超过时间还没有收到客户端的 ACK 消息，则重新发送一次 SYN-ACK 消息给客户端，直到重试超过一定次数时才会放弃。</p>
<p>服务端为了维持半开连接状态，需要分配内核资源维护半开连接。当攻击者伪造海量的虚假 IP 向服务端发送 SYN 包时，就形成了 SYN FLOOD 攻击。攻击者故意不响应 ACK 消息，导致服务端被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/3.png"></p>
<p><strong>防御手段：</strong></p>
<ul>
<li>直接的方法是提高 TCP 端口容量的同时减少半开连接的资源占用时间，然而该方法只是稍稍提高了防御能力；</li>
<li>部署能够辨别恶意 IP 的路由器，将伪造 IP 地址的发送方发送的 SYN 消息过滤掉，该方案作用一般不是太大；</li>
</ul>
<p>上述两种方法虽然在一定程度上能够提高服务器的防御能力，但是没有从根本上解决服务器资源消耗殆尽的问题，而以下几种方法的出发点都是在发送方发送确认回复后才开始分配传输资源，从而避免服务器资源消耗殆尽。</p>
<ul>
<li><p>SYN Cache：该方法首先构造一个全局 Hash Table，用来缓存系统当前所有的半开连接信息。在 Hash Table 中的每个桶的容量大小是有限制的，当桶满时，会主动丢掉最早来的信息。当服务端收到一个 SYN 消息后，会通过一个映射函数生成一个相应的 Key 值，使得当前半连接信息存入相应的桶中。当收到客户端正确的确认报文后，服务端才开始分配传输资源块，并将相应的半开连接信息从表中删除。和服务器传输资源相比，维护表的开销要小得多。</p>
</li>
<li><p>SYN Cookies：该方案原理和 HTTP Cookies 技术类似，服务端通过特定的算法将半开连接信息编码成序列号或者时间戳，用作服务端给客户端的消息编号，随 SYN-ACK 消息一同返回给连接发起方，这样在连接建立完成前服务端不保存任何信息，直到发送方发送 ACK 确认报文并且服务端成功验证编码信息后，服务端才开始分配传输资源。若请求方是攻击者，则不会向服务端会 ACK 消息，由于未成功建立连接，因此服务端并没有花费任何额外的开销。</p>
</li>
</ul>
<p>然而该方案也存在一些缺点，由于服务端并不保存半开连接状态，因此也就丧失了超时重传的能力，这在一定程度上降低了正常用户的连接成功率。此外，客户端发送给服务端的确认报文存在传输丢失的可能，当 ACK 确认报文丢失时，服务端和客户端会对连接的成功与否产生歧义，此时就需要上层应用采取相应的策略进行处理了。</p>
<ul>
<li>SYN Proxy：在客户端和服务器之间部署一个代理服务器，类似于防火墙的作用。通过代理服务器与客户端进行建立连接的过程，之后代理服务器充当客户端将成功建立连接的客户端信息发送给服务器。这种方法基本不消耗服务器的资源，但是建立连接的时间变长了（总共需要 6 次握手）。</li>
</ul>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段，随后开始四次挥手：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/network/2.png"></p>
<ol>
<li><p>首先客户端向服务器发送一段 TCP 报文表明其想要释放 TCP 连接，其中：</p>
<ul>
<li>标记位为 FIN，表示请求释放连接；</li>
<li>序号为 Seq = u；</li>
<li>随后客户端进入 FIN-WAIT-1 阶段，即半关闭阶段，并且停止向服务端发送通信数据。</li>
</ul>
</li>
<li><p>服务器接收到客户端请求断开连接的 FIN 报文后，结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段并返回一段 TCP 报文，其中：</p>
<ul>
<li>标记位为 ACK，表示接收到客户端释放连接的请求；</li>
<li>序号为 Seq = v；</li>
<li>确认号为 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号值加 1 作为本段报文确认号 Ack 的值；</li>
<li>随后服务器开始准备释放服务器端到客户端方向上的连接。</li>
</ul>
</li>
</ol>
<p>客户端收到服务器发送过来的 TCP 报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端结束 FIN-WAIT-1 阶段，进入 FIN-WAIT-2 阶 - 段。</p>
<ol start="3">
<li><p>服务器端在发出 ACK 确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经过 CLOSE-WAIT 阶段，便做好了释放服务器端到客户端的连接准备，再次向客户端发出一段 TCP 报文，其中：</p>
<ul>
<li>标记位为 FIN 和 ACK，表示已经准备好释放连接了；</li>
<li>序号为 Seq = w；</li>
<li>确认号 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号 Seq 的值加 1 作为本段报文确认号 Ack 的值。</li>
<li>随后服务器端结束 CLOSE-WAIT 阶段，进入 LAST-ACK 阶段。并且停止向客户端发送数据。</li>
</ul>
</li>
<li><p>客户端收到从服务器发来的 TCP 报文，确认了服务器已经做好释放连接的准备，于是结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器发送一段报文，其中：</p>
<ul>
<li>标记位为 ACK，表示接收到服务器准备好释放连接的信号；</li>
<li>序号为 Seq= u + 1，表示是在已收到服务器报文的基础上，将其确认号 Ack 值作为本段序号的值；</li>
<li>确认号为 Ack= w + 1，表示是在收到了服务器报文的基础上，将其序号 Seq 的值作为本段报文确认号的值。</li>
</ul>
</li>
</ol>
<p>随后客户端开始在 TIME-WAIT 阶段等待 2 MSL。服务器端收到从客户端发出的 TCP 报文之后结束 LAST-ACK 阶段，进入 CLOSED 阶段。由此正式确认关闭服务器端到客户端方向上的连接。客户端等待完 2 MSL 之后，结束 TIME-WAIT 阶段，进入 CLOSED 阶段，由此完成「四次挥手」。</p>
<h3 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h3><p>释放 TCP 连接时之所以需要四次挥手，是因为 FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的。 当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<h3 id="CLOSE-WAIT-和-TIME-WAIT-的状态和意义"><a href="#CLOSE-WAIT-和-TIME-WAIT-的状态和意义" class="headerlink" title="CLOSE-WAIT 和 TIME-WAIT 的状态和意义"></a>CLOSE-WAIT 和 TIME-WAIT 的状态和意义</h3><p>在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到了该请求之后，服务器进入了 CLOSE-WAIT 状态，然而此时有可能服务端还有一些数据没有传输完成，因此不能立即关闭连接，而 CLOSE-WAIT 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。</p>
<p>TIME-WAIT 发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入该状态，若取消该状态，即客户端在收到服务端的 FIN 报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现。除此之外，假设客户端最后一次发送的 ACK 包在传输的时候丢失了，由于 TCP 协议的超时重传机制，服务端将重发 FIN 报文，若客户端并没有维持 TIME-WAIT 状态而直接关闭的话，当收到服务端重新发送的 FIN 包时，客户端就会用 RST 包来响应服务端，这将会使得对方认为是有错误发生，然而其实只是正常的关闭连接过程，并没有出现异常情况。</p>
<h3 id="TIME-WAIT-为什么是-2MSL"><a href="#TIME-WAIT-为什么是-2MSL" class="headerlink" title="TIME-WAIT 为什么是 2MSL"></a>TIME-WAIT 为什么是 2MSL</h3><p>当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 2 MSL 的计时器。MSL（Maximum Segment Lifetime），指一段 TCP 报文在传输过程中的最大生命周期。2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。</p>
<p>若服务器在 1 MSL 内没有收到客户端发出的 ACK 确认报文，再次向客户端发出 FIN 报文。如果客户端在 2 MSL 内收到了服务器再次发来的 FIN 报文，说明服务器由于一些原因并没有收到客户端发出的 ACK 确认报文。客户端将再次向服务器发出 ACK 确认报文，并重新开始 2 MSL 的计时。</p>
<p>若客户端在 2MSL 内没有再次收到服务器发送的 FIN 报文，则说明服务器正常接收到客户端 ACK 确认报文，客户端可以进入 CLOSE 阶段，即完成四次挥手。</p>
<p>所以客户端要经历 2 MSL 时长的 TIME-WAIT 阶段，为的是确认服务器能否接收到客户端发出的 ACK 确认报文。</p>
<h3 id="TIME-WAIT-状态会导致什么问题，怎么解决"><a href="#TIME-WAIT-状态会导致什么问题，怎么解决" class="headerlink" title="TIME_WAIT 状态会导致什么问题，怎么解决"></a>TIME_WAIT 状态会导致什么问题，怎么解决</h3><p>我们考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。</p>
<p><strong>解决方案：</strong></p>
<p>修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。</p>
<p>服务器可以设置 SO_REUSEADDR 套接字选项来通知内核，如果端口被占用，但 TCP 连接位于 TIME_WAIT 状态时可以重用端口。如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时 SO_REUSEADDR 选项就可以避免 TIME-WAIT 状态。</p>
<p>也可以采用长连接的方式减少 TCP 的连接与断开，在长连接的业务中往往不需要考虑 TIME-WAIT 状态，但其实在长连接的业务中并发量一般不会太高。</p>
<h3 id="有很多-CLOSE-WAIT-怎么解决"><a href="#有很多-CLOSE-WAIT-怎么解决" class="headerlink" title="有很多 CLOSE-WAIT 怎么解决"></a>有很多 CLOSE-WAIT 怎么解决</h3><p>首先检查是不是自己的代码问题（看是否服务端程序忘记关闭连接），如果是，则修改代码。</p>
<p>调整系统参数，包括句柄相关参数和 TCP/IP 的参数，一般一个 CLOSE_WAIT 会维持至少 2 个小时的时间，我们可以通过调整参数来缩短这个时间。</p>

  
  
  <div class="footer">
      <script src="//m.servedby-buysellads.com/monetization.js" type="text/javascript"></script>
<div id="bsa-native"></div>
<script>
_bsa.init('custom', 'CKYD62QM', 'placement:vuejsorg',
  {
    target: '#bsa-native',
    template: '<a class="native-box" href="##statlink##"><div class="native-sponsor">Sponsor</div><div class="native-text"><strong>##company##</strong> — ##description##</div></a>'
  }
);
</script>


    Caught a mistake or want to contribute to the documentation?
    <a href="https://github.com/vuejs/vuejs.org/blob/master/src/network/tcp.md" rel="noopener" target="_blank">
      Edit this on GitHub!
    </a>
    <!-- Deployed on
    <a href="https://url.netlify.com/HJ8X2mxP8" rel="noopener" target="_blank">
      Netlify
    </a>. -->
  </div>
</div>

      </div>
      <script src="/js/smooth-scroll.min.js"></script>
    

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="/js/css.escape.js"></script>
    <script src="/js/common.js"></script>

    <!-- search -->
    <link href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" rel='stylesheet' type='text/css'>
    
<link rel="stylesheet" href="/css/search.css">

    <script src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <script>
    [
      '#search-query-nav',
      '#search-query-sidebar',
      '#search-query-menu'
    ].forEach(function (selector) {
      if (!document.querySelector(selector)) return
      // search index defaults to v2
      var match = window.location.pathname.match(/^\/(v\d+)/)
      var version = match ? match[1] : 'v2'
      docsearch({
      appId: 'BH4D9OD16A',
      apiKey: '85cc3221c9f23bfbaa4e3913dd7625ea',
      indexName: 'vuejs',
      inputSelector: selector,
      algoliaOptions: { facetFilters: ["version:" + version] },
      autocompleteOptions: { hint: false, appendTo: 'body'}
      })
    })
    </script>
  </body>
</html>
